<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<title>Szachy (kliknij, by grać) — AI, czas, poziom</title>
<style>
  :root{
    --light:#f0d9b5;
    --dark:#b58863;
    --accent:#2b8cff;
    --bg:#0f1720;
    --panel:#111827;
    --text:#e6eef6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter, Arial, sans-serif}
  .app{max-width:980px;margin:20px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.7)}
  h1{margin:0 0 8px 0;font-size:20px}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:var(--panel);color:var(--text);font-size:14px}
  #boardWrap{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap}
  .board{
    display:grid;
    grid-template-columns:repeat(8,56px);
    grid-template-rows:repeat(8,56px);
    width:448px;
    height:448px;
    border-radius:8px;
    overflow:hidden;
    box-shadow:0 8px 30px rgba(0,0,0,0.6);
    user-select:none;
  }
  .square{
    width:56px;height:56px;display:flex;justify-content:center;align-items:center;font-size:32px;cursor:pointer;
  }
  .square.light{background:var(--light);color:#202020}
  .square.dark{background:var(--dark);color:white}
  .square.selected{outline:3px solid var(--accent);box-sizing:border-box}
  .square.hint{box-shadow:inset 0 0 0 3px rgba(43,140,255,0.18)}
  .sidePanel{min-width:240px;display:flex;flex-direction:column;gap:12px}
  .timers{font-size:16px}
  .buttons{display:flex;gap:8px;flex-wrap:wrap}
  .status{font-size:14px;color:#cbd5e1}
  .pgn{background:#0b1220;padding:8px;border-radius:8px;font-family:monospace;font-size:13px;max-height:200px;overflow:auto}
  @media (max-width:800px){
    .board{transform:scale(0.8);transform-origin:left top}
  }
</style>
</head>
<body>
<div class="app">
  <h1>♟️ Szachy — kliknij, by zagrać</h1>

  <div class="controls">
    <label>Strona:
      <select id="side">
        <option value="w">Białe</option>
        <option value="b">Czarne</option>
      </select>
    </label>

    <label>Poziom AI:
      <select id="level">
        <option value="1">Łatwy</option>
        <option value="2">Średni</option>
        <option value="3">Trudny</option>
      </select>
    </label>

    <label>Czas (min):
      <select id="time">
        <option value="1">1</option>
        <option value="3" selected>3</option>
        <option value="5">5</option>
        <option value="10">10</option>
      </select>
    </label>

    <div class="buttons">
      <button id="startBtn">Start</button>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <div id="boardWrap">
    <div id="board" class="board" aria-label="Plansza szachowa"></div>

    <div class="sidePanel">
      <div class="timers">
        ⚪ <span id="whiteTime">-</span><br>
        ⚫ <span id="blackTime">-</span>
      </div>

      <div class="status" id="status">Status: gotowy</div>

      <div>
        <strong>PGN:</strong>
        <div class="pgn" id="pgnArea">—</div>
      </div>

      <div style="font-size:13px;color:#9aa7bb">
        Instrukcja: kliknij figurę, potem pole docelowe. Jeśli grasz czarnymi — plansza zostanie obrócona.
      </div>
    </div>
  </div>
</div>

<!-- chess.js (logika) -->
<script src="https://unpkg.com/chess.js@1.0.0/chess.min.js"></script>

<script>
/* ======= PROSTE, STABILNE SZACHY (klik) =======
   - plansza rysowana z Unicode (nie ma zewn. obrazków)
   - używa chess.js do reguł i ruchów
   - wybór koloru, czasu, poziomu
   - AI: minimax z alpha-beta (głębia zależna od poziomu)
   - klik: wybierz figurę -> wybierz pole
*/

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const pgnEl = document.getElementById('pgnArea');
const whiteTimeEl = document.getElementById('whiteTime');
const blackTimeEl = document.getElementById('blackTime');

let game = new Chess();
let playerColor = 'w';   // 'w' lub 'b'
let aiColor = 'b';
let aiDepth = 1;

let selectedSquare = null;
let validTargets = [];

let timers = { w:0, b:0 };
let timerInterval = null;
let gameRunning = false;

// Unicode pieces
const PIECE_UNICODE = {
  w: { p: '♙', r: '♖', n: '♘', b: '♗', q: '♕', k: '♔' },
  b: { p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚' }
};

// create 8x8 squares (we re-render content only)
function buildEmptyBoard() {
  boardEl.innerHTML = '';
  // board squares from 8 to 1 top->bottom; files a->h left->right
  for (let rank = 8; rank >= 1; rank--) {
    for (let file = 0; file < 8; file++) {
      const sq = document.createElement('div');
      const fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
      const coord = fileChar + rank;
      sq.className = 'square';
      // color
      const isLight = ((rank + file) % 2 === 0);
      sq.classList.add(isLight ? 'light' : 'dark');
      sq.dataset.square = coord;
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
  }
}

// render pieces according to game.fen()
function renderBoard() {
  // If player chose black, flip board by reversing order of squares in DOM visually
  const orientation = playerColor === 'w' ? 1 : -1;
  // We'll map each square element by coordinate
  const squares = {};
  boardEl.querySelectorAll('.square').forEach(el => squares[el.dataset.square] = el);

  // clear selections/hints and text
  Object.values(squares).forEach(el => { el.classList.remove('selected','hint'); el.textContent = ''; });

  const board = game.board(); // 8x8 array, [0] is rank 8
  for (let r = 0; r < 8; r++) {
    for (let f = 0; f < 8; f++) {
      const piece = board[r][f];
      if (!piece) continue;
      const rank = 8 - r;
      const fileChar = String.fromCharCode('a'.charCodeAt(0)+f);
      const coord = fileChar + rank;
      const el = squares[coord];
      if (el) el.textContent = PIECE_UNICODE[piece.color][piece.type];
    }
  }

  // highlight selected and hints
  if (selectedSquare) {
    const sel = squares[selectedSquare];
    if (sel) sel.classList.add('selected');
    validTargets.forEach(t => { if (squares[t]) squares[t].classList.add('hint'); });
  }

  // update PGN and status
  pgnEl.textContent = game.pgn() || '—';
  statusEl.textContent = `Status: ${game.turn() === 'w' ? 'Ruch białych' : 'Ruch czarnych'}${game.in_check() ? ' — szach!' : ''}${game.game_over() ? ' — koniec gry' : ''}`;
}

// handle click on a square
function onSquareClick(e) {
  if (!gameRunning) return;
  const sq = e.currentTarget.dataset.square;

  // if nothing selected yet: try to select a piece belonging to the player
  if (!selectedSquare) {
    const piece = game.get(sq);
    if (!piece) return;
    if (piece.color !== playerColor) return; // can't pick opponent piece
    // select and show valid moves
    selectedSquare = sq;
    const moves = game.moves({ square: sq, verbose: true });
    validTargets = moves.map(m => m.to);
    renderBoard();
    return;
  }

  // if clicked same square -> deselect
  if (selectedSquare === sq) {
    selectedSquare = null; validTargets = []; renderBoard(); return;
  }

  // if target is a valid move, try to make move
  if (validTargets.includes(sq)) {
    const move = game.move({ from: selectedSquare, to: sq, promotion: 'q' });
    selectedSquare = null; validTargets = [];
    renderBoard();

    // after player's move, check game over or start AI move
    if (game.game_over()) {
      handleGameOver();
      return;
    }

    // AI move (with slight delay)
    setTimeout(() => {
      if (!game.game_over()) makeAIMove();
    }, 200);
    return;
  }

  // else clicked some other square: try selecting new own piece
  const piece = game.get(sq);
  if (piece && piece.color === playerColor) {
    selectedSquare = sq;
    validTargets = game.moves({ square: sq, verbose: true }).map(m => m.to);
    renderBoard();
  } else {
    // click on other square -> clear selection
    selectedSquare = null; validTargets = []; renderBoard();
  }
}

// AI: minimax with alpha-beta; evaluation by material (simple)
function evaluateBoard(board) {
  const values = { p:100, n:320, b:330, r:500, q:900, k:20000 };
  let score = 0;
  for (let r of board) {
    for (let p of r) {
      if (!p) continue;
      const v = values[p.type] || 0;
      score += (p.color === 'w') ? v : -v;
    }
  }
  return score;
}
function evaluateForAI(board) {
  const raw = evaluateBoard(board);
  return (aiColor === 'w') ? raw : -raw;
}

function minimax(depth, alpha, beta, isMaximizing) {
  if (depth === 0 || game.game_over()) return evaluateForAI(game.board());

  const moves = game.moves({ verbose: true });
  if (isMaximizing) {
    let maxEval = -Infinity;
    for (let m of moves) {
      game.move({from: m.from, to: m.to, promotion: m.promotion || 'q'});
      const eval = minimax(depth - 1, alpha, beta, false);
      game.undo();
      if (eval > maxEval) maxEval = eval;
      if (eval > alpha) alpha = eval;
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let m of moves) {
      game.move({from: m.from, to: m.to, promotion: m.promotion || 'q'});
      const eval = minimax(depth - 1, alpha, beta, true);
      game.undo();
      if (eval < minEval) minEval = eval;
      if (eval < beta) beta = eval;
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function findBestMove(depth) {
  const moves = game.moves({ verbose: true });
  if (moves.length === 0) return null;
  let bestMove = moves[0];
  let bestValue = -Infinity;
  for (let m of moves) {
    game.move({from: m.from, to: m.to, promotion: m.promotion || 'q'});
    const value = minimax(depth - 1, -Infinity, Infinity, false);
    game.undo();
    if (value > bestValue) { bestValue = value; bestMove = m; }
  }
  return bestMove;
}

function makeAIMove() {
  if (game.game_over()) { handleGameOver(); return; }
  // AI thinks for short time depending on level
  const depth = aiDepth + 0; // easy=1, medium=2, hard=3
  const m = findBestMove(depth);
  if (!m) { handleGameOver(); return; }
  game.move({from: m.from, to: m.to, promotion: m.promotion || 'q'});
  renderBoard();
  if (game.game_over()) handleGameOver();
}

// timers
function startTimers(totalSeconds) {
  timers.w = timers.b = totalSeconds;
  updateTimerDisplay();
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!gameRunning) return;
    const turn = game.turn(); // 'w' or 'b'
    timers[turn]--;
    updateTimerDisplay();
    if (timers.w <= 0 || timers.b <= 0) {
      gameRunning = false;
      clearInterval(timerInterval);
      const loser = timers.w <= 0 ? 'w' : 'b';
      const winner = loser === 'w' ? 'b' : 'w';
      statusEl.textContent = `Koniec czasu — wygrały ${winner === 'w' ? 'Białe' : 'Czarne'}`;
    }
  }, 1000);
}
function updateTimerDisplay(){ whiteTimeEl.textContent = formatTime(timers.w); blackTimeEl.textContent = formatTime(timers.b); }
function formatTime(sec){ if (sec<0) sec=0; const m=Math.floor(sec/60), s=sec%60; return `${m}:${String(s).padStart(2,'0')}`; }

// start / restart
function startGame() {
  // read settings
  const sideSel = document.getElementById('side').value;
  const levelSel = parseInt(document.getElementById('level').value,10);
  const timeMin = parseInt(document.getElementById('time').value,10);

  playerColor = sideSel;
  aiColor = playerColor === 'w' ? 'b' : 'w';
  aiDepth = levelSel; // 1..3
  const seconds = timeMin * 60;

  game = new Chess();
  selectedSquare = null; validTargets = [];
  buildEmptyBoard();
  // if player is black, flip visual order of squares by reversing DOM order
  if (playerColor === 'b') flipBoardDOM();
  renderBoard();

  // timers
  startTimers(seconds);

  gameRunning = true;
  statusEl.textContent = 'Rozpoczęto grę';

  // if player chose black -> AI (white) starts
  if (playerColor === 'b') {
    setTimeout(() => { makeAIMove(); }, 300);
  }
}

function flipBoardDOM(){
  // reverse children so that a8 is top-left when player is black
  const nodes = Array.from(boardEl.children);
  boardEl.innerHTML = '';
  nodes.reverse().forEach(n => boardEl.appendChild(n));
}

function handleGameOver() {
  gameRunning = false;
  clearInterval(timerInterval);
  if (game.in_checkmate()) {
    const winner = game.turn() === 'w' ? 'Czarne' : 'Białe';
    statusEl.textContent = `Mat — wygrały ${winner}`;
  } else if (game.in_draw()) {
    statusEl.textContent = 'Remis';
  } else {
    statusEl.textContent = 'Koniec gry';
  }
}

// initial build
buildEmptyBoard();
renderBoard();

// buttons
document.getElementById('startBtn').addEventListener('click', () => startGame());
document.getElementById('restartBtn').addEventListener('click', () => {
  // just restart with same settings
  startGame();
});

</script>
</body>
</html>
